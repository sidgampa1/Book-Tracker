"use strict";
/* eslint-disable */
/* tslint:disable */
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Api = exports.HttpClient = exports.ContentType = exports.SupportTicketSeverity = exports.IdentitySupportedAuthProvider = exports.OrgDeletionConditionName = exports.UserDeletionConditionName = exports.IdentityProviderId = exports.MemberRole = exports.BillingPaymentMethod = exports.BillingSubscriptionType = exports.BillingAccountState = exports.EndpointPoolerMode = exports.EndpointType = exports.EndpointState = exports.ConsumptionHistoryGranularity = exports.OperationStatus = exports.OperationAction = void 0;
/** The action performed by the operation */
var OperationAction;
(function (OperationAction) {
    OperationAction["CreateCompute"] = "create_compute";
    OperationAction["CreateTimeline"] = "create_timeline";
    OperationAction["StartCompute"] = "start_compute";
    OperationAction["SuspendCompute"] = "suspend_compute";
    OperationAction["ApplyConfig"] = "apply_config";
    OperationAction["CheckAvailability"] = "check_availability";
    OperationAction["DeleteTimeline"] = "delete_timeline";
    OperationAction["CreateBranch"] = "create_branch";
    OperationAction["TenantIgnore"] = "tenant_ignore";
    OperationAction["TenantAttach"] = "tenant_attach";
    OperationAction["TenantDetach"] = "tenant_detach";
    OperationAction["TenantReattach"] = "tenant_reattach";
    OperationAction["ReplaceSafekeeper"] = "replace_safekeeper";
    OperationAction["DisableMaintenance"] = "disable_maintenance";
    OperationAction["ApplyStorageConfig"] = "apply_storage_config";
    OperationAction["PrepareSecondaryPageserver"] = "prepare_secondary_pageserver";
    OperationAction["SwitchPageserver"] = "switch_pageserver";
    OperationAction["DetachParentBranch"] = "detach_parent_branch";
    OperationAction["TimelineArchive"] = "timeline_archive";
    OperationAction["TimelineUnarchive"] = "timeline_unarchive";
    OperationAction["StartReservedCompute"] = "start_reserved_compute";
    OperationAction["SyncDbsAndRolesFromCompute"] = "sync_dbs_and_roles_from_compute";
})(OperationAction || (exports.OperationAction = OperationAction = {}));
/** The status of the operation */
var OperationStatus;
(function (OperationStatus) {
    OperationStatus["Scheduling"] = "scheduling";
    OperationStatus["Running"] = "running";
    OperationStatus["Finished"] = "finished";
    OperationStatus["Failed"] = "failed";
    OperationStatus["Error"] = "error";
    OperationStatus["Cancelling"] = "cancelling";
    OperationStatus["Cancelled"] = "cancelled";
    OperationStatus["Skipped"] = "skipped";
})(OperationStatus || (exports.OperationStatus = OperationStatus = {}));
var ConsumptionHistoryGranularity;
(function (ConsumptionHistoryGranularity) {
    ConsumptionHistoryGranularity["Hourly"] = "hourly";
    ConsumptionHistoryGranularity["Daily"] = "daily";
    ConsumptionHistoryGranularity["Monthly"] = "monthly";
})(ConsumptionHistoryGranularity || (exports.ConsumptionHistoryGranularity = ConsumptionHistoryGranularity = {}));
/** The state of the compute endpoint */
var EndpointState;
(function (EndpointState) {
    EndpointState["Init"] = "init";
    EndpointState["Active"] = "active";
    EndpointState["Idle"] = "idle";
})(EndpointState || (exports.EndpointState = EndpointState = {}));
/** The compute endpoint type. Either `read_write` or `read_only`. */
var EndpointType;
(function (EndpointType) {
    EndpointType["ReadOnly"] = "read_only";
    EndpointType["ReadWrite"] = "read_write";
})(EndpointType || (exports.EndpointType = EndpointType = {}));
/** The connection pooler mode. Neon supports PgBouncer in `transaction` mode only. */
var EndpointPoolerMode;
(function (EndpointPoolerMode) {
    EndpointPoolerMode["Transaction"] = "transaction";
})(EndpointPoolerMode || (exports.EndpointPoolerMode = EndpointPoolerMode = {}));
/** State of the billing account. */
var BillingAccountState;
(function (BillingAccountState) {
    BillingAccountState["UNKNOWN"] = "UNKNOWN";
    BillingAccountState["Active"] = "active";
    BillingAccountState["Suspended"] = "suspended";
    BillingAccountState["Deactivated"] = "deactivated";
    BillingAccountState["Deleted"] = "deleted";
})(BillingAccountState || (exports.BillingAccountState = BillingAccountState = {}));
/**
 * Type of subscription to Neon Cloud.
 * Notice that for users without billing account this will be "UNKNOWN"
 */
var BillingSubscriptionType;
(function (BillingSubscriptionType) {
    BillingSubscriptionType["UNKNOWN"] = "UNKNOWN";
    BillingSubscriptionType["DirectSales"] = "direct_sales";
    BillingSubscriptionType["AwsMarketplace"] = "aws_marketplace";
    BillingSubscriptionType["FreeV2"] = "free_v2";
    BillingSubscriptionType["Launch"] = "launch";
    BillingSubscriptionType["Scale"] = "scale";
    BillingSubscriptionType["Business"] = "business";
    BillingSubscriptionType["VercelPgLegacy"] = "vercel_pg_legacy";
})(BillingSubscriptionType || (exports.BillingSubscriptionType = BillingSubscriptionType = {}));
/** Indicates whether and how an account makes payments. */
var BillingPaymentMethod;
(function (BillingPaymentMethod) {
    BillingPaymentMethod["UNKNOWN"] = "UNKNOWN";
    BillingPaymentMethod["None"] = "none";
    BillingPaymentMethod["Stripe"] = "stripe";
    BillingPaymentMethod["DirectPayment"] = "direct_payment";
    BillingPaymentMethod["AwsMp"] = "aws_mp";
    BillingPaymentMethod["AzureMp"] = "azure_mp";
    BillingPaymentMethod["VercelMp"] = "vercel_mp";
    BillingPaymentMethod["Staff"] = "staff";
    BillingPaymentMethod["Trial"] = "trial";
    BillingPaymentMethod["Sponsorship"] = "sponsorship";
})(BillingPaymentMethod || (exports.BillingPaymentMethod = BillingPaymentMethod = {}));
/** The role of the organization member */
var MemberRole;
(function (MemberRole) {
    MemberRole["Admin"] = "admin";
    MemberRole["Member"] = "member";
})(MemberRole || (exports.MemberRole = MemberRole = {}));
/** Identity provider id from keycloak */
var IdentityProviderId;
(function (IdentityProviderId) {
    IdentityProviderId["Github"] = "github";
    IdentityProviderId["Google"] = "google";
    IdentityProviderId["Hasura"] = "hasura";
    IdentityProviderId["Microsoft"] = "microsoft";
    IdentityProviderId["Vercelmp"] = "vercelmp";
    IdentityProviderId["Keycloak"] = "keycloak";
    IdentityProviderId["Test"] = "test";
})(IdentityProviderId || (exports.IdentityProviderId = IdentityProviderId = {}));
var UserDeletionConditionName;
(function (UserDeletionConditionName) {
    UserDeletionConditionName["ProjectCount"] = "project_count";
    UserDeletionConditionName["OrgAdminMembershipCount"] = "org_admin_membership_count";
    UserDeletionConditionName["SubscriptionType"] = "subscription_type";
})(UserDeletionConditionName || (exports.UserDeletionConditionName = UserDeletionConditionName = {}));
var OrgDeletionConditionName;
(function (OrgDeletionConditionName) {
    OrgDeletionConditionName["ProjectCount"] = "project_count";
})(OrgDeletionConditionName || (exports.OrgDeletionConditionName = OrgDeletionConditionName = {}));
var IdentitySupportedAuthProvider;
(function (IdentitySupportedAuthProvider) {
    IdentitySupportedAuthProvider["Mock"] = "mock";
    IdentitySupportedAuthProvider["Stack"] = "stack";
})(IdentitySupportedAuthProvider || (exports.IdentitySupportedAuthProvider = IdentitySupportedAuthProvider = {}));
var SupportTicketSeverity;
(function (SupportTicketSeverity) {
    SupportTicketSeverity["Low"] = "low";
    SupportTicketSeverity["Normal"] = "normal";
    SupportTicketSeverity["High"] = "high";
    SupportTicketSeverity["Critical"] = "critical";
})(SupportTicketSeverity || (exports.SupportTicketSeverity = SupportTicketSeverity = {}));
var axios_1 = require("axios");
var ContentType;
(function (ContentType) {
    ContentType["Json"] = "application/json";
    ContentType["FormData"] = "multipart/form-data";
    ContentType["UrlEncoded"] = "application/x-www-form-urlencoded";
    ContentType["Text"] = "text/plain";
})(ContentType || (exports.ContentType = ContentType = {}));
var HttpClient = /** @class */ (function () {
    function HttpClient(_a) {
        if (_a === void 0) { _a = {}; }
        var _this = this;
        var securityWorker = _a.securityWorker, secure = _a.secure, format = _a.format, axiosConfig = __rest(_a, ["securityWorker", "secure", "format"]);
        this.securityData = null;
        this.setSecurityData = function (data) {
            _this.securityData = data;
        };
        this.request = function (_a) { return __awaiter(_this, void 0, void 0, function () {
            var secureParams, _b, requestParams, responseFormat;
            var secure = _a.secure, path = _a.path, type = _a.type, query = _a.query, format = _a.format, body = _a.body, params = __rest(_a, ["secure", "path", "type", "query", "format", "body"]);
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (typeof secure === 'boolean' ? secure : this.secure) &&
                            this.securityWorker;
                        if (!_b) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.securityWorker(this.securityData)];
                    case 1:
                        _b = (_c.sent());
                        _c.label = 2;
                    case 2:
                        secureParams = (_b) ||
                            {};
                        requestParams = this.mergeRequestParams(params, secureParams);
                        responseFormat = format || this.format || undefined;
                        if (type === ContentType.FormData && body && body !== null && typeof body === 'object') {
                            body = this.createFormData(body);
                        }
                        if (type === ContentType.Text && body && body !== null && typeof body !== 'string') {
                            body = JSON.stringify(body);
                        }
                        return [2 /*return*/, this.instance.request(__assign(__assign({}, requestParams), { headers: __assign(__assign({}, (requestParams.headers || {})), (type ? { 'Content-Type': type } : {})), params: query, responseType: responseFormat, data: body, url: path }))];
                }
            });
        }); };
        this.instance = axios_1.default.create(__assign(__assign({}, axiosConfig), { baseURL: axiosConfig.baseURL || 'https://console.neon.tech/api/v2' }));
        this.secure = secure;
        this.format = format;
        this.securityWorker = securityWorker;
    }
    HttpClient.prototype.mergeRequestParams = function (params1, params2) {
        var method = params1.method || (params2 && params2.method);
        return __assign(__assign(__assign(__assign({}, this.instance.defaults), params1), (params2 || {})), { headers: __assign(__assign(__assign({}, ((method && this.instance.defaults.headers[method.toLowerCase()]) || {})), (params1.headers || {})), ((params2 && params2.headers) || {})) });
    };
    HttpClient.prototype.stringifyFormItem = function (formItem) {
        if (typeof formItem === 'object' && formItem !== null) {
            return JSON.stringify(formItem);
        }
        else {
            return "".concat(formItem);
        }
    };
    HttpClient.prototype.createFormData = function (input) {
        var _this = this;
        if (input instanceof FormData) {
            return input;
        }
        return Object.keys(input || {}).reduce(function (formData, key) {
            var property = input[key];
            var propertyContent = property instanceof Array ? property : [property];
            for (var _i = 0, propertyContent_1 = propertyContent; _i < propertyContent_1.length; _i++) {
                var formItem = propertyContent_1[_i];
                var isFileType = formItem instanceof Blob || formItem instanceof File;
                formData.append(key, isFileType ? formItem : _this.stringifyFormItem(formItem));
            }
            return formData;
        }, new FormData());
    };
    return HttpClient;
}());
exports.HttpClient = HttpClient;
/**
 * @title Neon API
 * @version v2
 * @license Proprietary
 * @baseUrl https://console.neon.tech/api/v2
 * @contact <support@neon.tech>
 *
 * The Neon API allows you to access and manage Neon programmatically. You can use the Neon API to manage API keys, projects, branches, compute endpoints, databases, roles, and operations. For information about these features, refer to the [Neon documentation](https://neon.tech/docs/manage/overview/).
 *
 * You can run Neon API requests from this API reference using the **Try It** feature. Enter your API key as a **Bearer** token in the **Authoization** section of the page.
 *
 * You can create and manage API keys in the Neon Console. See [Manage API keys](https://neon.tech/docs/manage/api-keys/) for instructions.
 */
var Api = /** @class */ (function (_super) {
    __extends(Api, _super);
    function Api() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * @description Retrieves the API keys for your Neon account. The response does not include API key tokens. A token is only provided when creating an API key. API keys can also be managed in the Neon Console. For more information, see [Manage API keys](https://neon.tech/docs/manage/api-keys/).
         *
         * @tags API Key
         * @name ListApiKeys
         * @summary Get a list of API keys
         * @request GET:/api_keys
         * @secure
         */
        _this.listApiKeys = function (params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/api_keys", method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Creates an API key. The `key_name` is a user-specified name for the key. This method returns an `id` and `key`. The `key` is a randomly generated, 64-bit token required to access the Neon API. API keys can also be managed in the Neon Console. See [Manage API keys](https://neon.tech/docs/manage/api-keys/).
         *
         * @tags API Key
         * @name CreateApiKey
         * @summary Create an API key
         * @request POST:/api_keys
         * @secure
         */
        _this.createApiKey = function (data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/api_keys", method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Revokes the specified API key. An API key that is no longer needed can be revoked. This action cannot be reversed. You can obtain `key_id` values by listing the API keys for your Neon account. API keys can also be managed in the Neon Console. See [Manage API keys](https://neon.tech/docs/manage/api-keys/).
         *
         * @tags API Key
         * @name RevokeApiKey
         * @summary Revoke an API key
         * @request DELETE:/api_keys/{key_id}
         * @secure
         */
        _this.revokeApiKey = function (keyId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/api_keys/".concat(encodeURIComponent(keyId)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves details for the specified operation. An operation is an action performed on a Neon project resource. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain a `operation_id` by listing operations for the project.
         *
         * @tags Operation
         * @name GetProjectOperation
         * @summary Get operation details
         * @request GET:/projects/{project_id}/operations/{operation_id}
         * @secure
         */
        _this.getProjectOperation = function (projectId, operationId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/operations/").concat(encodeURIComponent(operationId)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves a list of projects for the Neon account. A project is the top-level object in the Neon object hierarchy. For more information, see [Manage projects](https://neon.tech/docs/manage/projects/).
         *
         * @tags Project
         * @name ListProjects
         * @summary Get a list of projects
         * @request GET:/projects
         * @secure
         */
        _this.listProjects = function (query, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects", method: 'GET', query: query, secure: true, format: 'json' }, params));
        };
        /**
         * @description Creates a Neon project. A project is the top-level object in the Neon object hierarchy. Plan limits define how many projects you can create. For more information, see [Manage projects](https://neon.tech/docs/manage/projects/). You can specify a region and Postgres version in the request body. Neon currently supports PostgreSQL 14, 15, 16, and 17. For supported regions and `region_id` values, see [Regions](https://neon.tech/docs/introduction/regions/).
         *
         * @tags Project
         * @name CreateProject
         * @summary Create a project
         * @request POST:/projects
         * @secure
         */
        _this.createProject = function (data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects", method: 'POST', body: data, secure: true, type: ContentType.Json }, params));
        };
        /**
         * @description Retrieves a list of shared projects for the Neon account. A project is the top-level object in the Neon object hierarchy. For more information, see [Manage projects](https://neon.tech/docs/manage/projects/).
         *
         * @tags Project
         * @name ListSharedProjects
         * @summary Get a list of shared projects
         * @request GET:/projects/shared
         * @secure
         */
        _this.listSharedProjects = function (query, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/shared", method: 'GET', query: query, secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about the specified project. A project is the top-level object in the Neon object hierarchy. You can obtain a `project_id` by listing the projects for your Neon account.
         *
         * @tags Project
         * @name GetProject
         * @summary Get project details
         * @request GET:/projects/{project_id}
         * @secure
         */
        _this.getProject = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Updates the specified project. You can obtain a `project_id` by listing the projects for your Neon account. Neon permits updating the project name only.
         *
         * @tags Project
         * @name UpdateProject
         * @summary Update a project
         * @request PATCH:/projects/{project_id}
         * @secure
         */
        _this.updateProject = function (projectId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId)), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Deletes the specified project. You can obtain a `project_id` by listing the projects for your Neon account. Deleting a project is a permanent action. Deleting a project also deletes endpoints, branches, databases, and users that belong to the project.
         *
         * @tags Project
         * @name DeleteProject
         * @summary Delete a project
         * @request DELETE:/projects/{project_id}
         * @secure
         */
        _this.deleteProject = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves a list of operations for the specified Neon project. You can obtain a `project_id` by listing the projects for your Neon account. The number of operations returned can be large. To paginate the response, issue an initial request with a `limit` value. Then, add the `cursor` value that was returned in the response to the next request.
         *
         * @tags Operation
         * @name ListProjectOperations
         * @summary Get a list of operations
         * @request GET:/projects/{project_id}/operations
         * @secure
         */
        _this.listProjectOperations = function (_a, params) {
            var projectId = _a.projectId, query = __rest(_a, ["projectId"]);
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/operations"), method: 'GET', query: query, secure: true }, params));
        };
        /**
         * @description Retrieves details about users who have access to the project, including the permission `id`, the granted-to email address, and the date project access was granted.
         *
         * @tags Project
         * @name ListProjectPermissions
         * @summary List project access
         * @request GET:/projects/{project_id}/permissions
         * @secure
         */
        _this.listProjectPermissions = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/permissions"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Grants project access to the account associated with the specified email address
         *
         * @tags Project
         * @name GrantPermissionToProject
         * @summary Grant project access
         * @request POST:/projects/{project_id}/permissions
         * @secure
         */
        _this.grantPermissionToProject = function (projectId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/permissions"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Revokes project access from the user associted with the specified permisison `id`. You can retrieve a user's permission `id` by listing project access.
         *
         * @tags Project
         * @name RevokePermissionFromProject
         * @summary Revoke project access
         * @request DELETE:/projects/{project_id}/permissions/{permission_id}
         * @secure
         */
        _this.revokePermissionFromProject = function (projectId, permissionId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/permissions/").concat(encodeURIComponent(permissionId)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Returns all the available JWKS URLs that can be used for verifying JWTs used as the authentication mechanism for the specified project.
         *
         * @tags Project
         * @name GetProjectJwks
         * @summary Returns all available JWKS URLs for a project
         * @request GET:/projects/{project_id}/jwks
         * @secure
         */
        _this.getProjectJwks = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/jwks"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Add a new JWKS URL to a project, such that it can be used for verifying JWTs used as the authentication mechanism for the specified project. The URL must be a valid HTTPS URL that returns a JSON Web Key Set. The `provider_name` field allows you to specify which authentication provider you're using (e.g., Clerk, Auth0, AWS Cognito, etc.). The `branch_id` can be used to specify on which branches the JWKS URL will be accepted. If not specified, then it will work on any branch. The `role_names` can be used to specify for which roles the JWKS URL will be accepted. The `jwt_audience` can be used to specify which "aud" values should be accepted by Neon in the JWTs that are used for authentication.
         *
         * @tags Project
         * @name AddProjectJwks
         * @summary Adds a JWKS URL to a project
         * @request POST:/projects/{project_id}/jwks
         * @secure
         */
        _this.addProjectJwks = function (projectId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/jwks"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Deletes a JWKS URL from the specified project
         *
         * @tags Project
         * @name DeleteProjectJwks
         * @summary Delete a JWKS URL
         * @request DELETE:/projects/{project_id}/jwks/{jwks_id}
         * @secure
         */
        _this.deleteProjectJwks = function (projectId, jwksId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/jwks/").concat(encodeURIComponent(jwksId)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves a connection URI for the specified database. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `database_name` by listing the databases for a branch. You can obtain a `role_name` by listing the roles for a branch.
         *
         * @tags Project
         * @name GetConnectionUri
         * @summary Get a connection URI
         * @request GET:/projects/{project_id}/connection_uri
         * @secure
         */
        _this.getConnectionUri = function (_a, params) {
            var projectId = _a.projectId, query = __rest(_a, ["projectId"]);
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/connection_uri"), method: 'GET', query: query, secure: true, format: 'json' }, params));
        };
        /**
         * @description Creates a branch in the specified project. You can obtain a `project_id` by listing the projects for your Neon account. This method does not require a request body, but you can specify one to create a compute endpoint for the branch or to select a non-default parent branch. The default behavior is to create a branch from the project's default branch with no compute endpoint, and the branch name is auto-generated. There is a maximum of one read-write endpoint per branch. A branch can have multiple read-only endpoints. For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
         *
         * @tags Branch
         * @name CreateProjectBranch
         * @summary Create a branch
         * @request POST:/projects/{project_id}/branches
         * @secure
         */
        _this.createProjectBranch = function (projectId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches"), method: 'POST', body: data, secure: true, type: ContentType.Json }, params));
        };
        /**
         * @description Retrieves a list of branches for the specified project. You can obtain a `project_id` by listing the projects for your Neon account. Each Neon project has a root branch named `main`. A `branch_id` value has a `br-` prefix. A project may contain child branches that were branched from `main` or from another branch. A parent branch is identified by the `parent_id` value, which is the `id` of the parent branch. For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
         *
         * @tags Branch
         * @name ListProjectBranches
         * @summary Get a list of branches
         * @request GET:/projects/{project_id}/branches
         * @secure
         */
        _this.listProjectBranches = function (_a, params) {
            var projectId = _a.projectId, query = __rest(_a, ["projectId"]);
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches"), method: 'GET', query: query, secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about the specified branch. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain a `branch_id` by listing the project's branches. A `branch_id` value has a `br-` prefix. Each Neon project is initially created with a root and default branch named `main`. A project can contain one or more branches. A parent branch is identified by a `parent_id` value, which is the `id` of the parent branch. For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
         *
         * @tags Branch
         * @name GetProjectBranch
         * @summary Get branch details
         * @request GET:/projects/{project_id}/branches/{branch_id}
         * @secure
         */
        _this.getProjectBranch = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Deletes the specified branch from a project, and places all compute endpoints into an idle state, breaking existing client connections. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain a `branch_id` by listing the project's branches. For related information, see [Manage branches](https://neon.tech/docs/manage/branches/). When a successful response status is received, the compute endpoints are still active, and the branch is not yet deleted from storage. The deletion occurs after all operations finish. You cannot delete a project's root or default branch, and you cannot delete a branch that has a child branch. A project must have at least one branch.
         *
         * @tags Branch
         * @name DeleteProjectBranch
         * @summary Delete a branch
         * @request DELETE:/projects/{project_id}/branches/{branch_id}
         * @secure
         */
        _this.deleteProjectBranch = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Updates the specified branch. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. For more information, see [Manage branches](https://neon.tech/docs/manage/branches/).
         *
         * @tags Branch
         * @name UpdateProjectBranch
         * @summary Update a branch
         * @request PATCH:/projects/{project_id}/branches/{branch_id}
         * @secure
         */
        _this.updateProjectBranch = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId)), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Restores a branch to an earlier state in its own or another branch's history
         *
         * @tags Branch
         * @name RestoreProjectBranch
         * @summary Restore a branch
         * @request POST:/projects/{project_id}/branches/{branch_id}/restore
         * @secure
         */
        _this.restoreProjectBranch = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/restore"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Retrieves the schema from the specified database. The `lsn` and `timestamp` values cannot be specified at the same time. If both are omitted, the database schema is retrieved from database's head.
         *
         * @tags Branch
         * @name GetProjectBranchSchema
         * @summary Get the database schema
         * @request GET:/projects/{project_id}/branches/{branch_id}/schema
         * @secure
         */
        _this.getProjectBranchSchema = function (_a, params) {
            var projectId = _a.projectId, branchId = _a.branchId, query = __rest(_a, ["projectId", "branchId"]);
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/schema"), method: 'GET', query: query, secure: true, format: 'json' }, params));
        };
        /**
         * @description Sets the specified branch as the project's default branch. The default designation is automatically removed from the previous default branch. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. For more information, see [Manage branches](https://neon.tech/docs/manage/branches/).
         *
         * @tags Branch
         * @name SetDefaultProjectBranch
         * @summary Set branch as default
         * @request POST:/projects/{project_id}/branches/{branch_id}/set_as_default
         * @secure
         */
        _this.setDefaultProjectBranch = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/set_as_default"), method: 'POST', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves a list of compute endpoints for the specified branch. Neon permits only one read-write compute endpoint per branch. A branch can have multiple read-only compute endpoints. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches.
         *
         * @tags Branch
         * @name ListProjectBranchEndpoints
         * @summary Get a list of branch endpoints
         * @request GET:/projects/{project_id}/branches/{branch_id}/endpoints
         * @secure
         */
        _this.listProjectBranchEndpoints = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/endpoints"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves a list of databases for the specified branch. A branch can have multiple databases. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
         *
         * @tags Branch
         * @name ListProjectBranchDatabases
         * @summary Get a list of databases
         * @request GET:/projects/{project_id}/branches/{branch_id}/databases
         * @secure
         */
        _this.listProjectBranchDatabases = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/databases"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Creates a database in the specified branch. A branch can have multiple databases. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
         *
         * @tags Branch
         * @name CreateProjectBranchDatabase
         * @summary Create a database
         * @request POST:/projects/{project_id}/branches/{branch_id}/databases
         * @secure
         */
        _this.createProjectBranchDatabase = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/databases"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about the specified database. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` and `database_name` by listing the branch's databases. For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
         *
         * @tags Branch
         * @name GetProjectBranchDatabase
         * @summary Get database details
         * @request GET:/projects/{project_id}/branches/{branch_id}/databases/{database_name}
         * @secure
         */
        _this.getProjectBranchDatabase = function (projectId, branchId, databaseName, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/databases/").concat(encodeURIComponent(databaseName)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Updates the specified database in the branch. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` and `database_name` by listing the branch's databases. For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
         *
         * @tags Branch
         * @name UpdateProjectBranchDatabase
         * @summary Update a database
         * @request PATCH:/projects/{project_id}/branches/{branch_id}/databases/{database_name}
         * @secure
         */
        _this.updateProjectBranchDatabase = function (projectId, branchId, databaseName, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/databases/").concat(encodeURIComponent(databaseName)), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Deletes the specified database from the branch. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` and `database_name` by listing the branch's databases. For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
         *
         * @tags Branch
         * @name DeleteProjectBranchDatabase
         * @summary Delete a database
         * @request DELETE:/projects/{project_id}/branches/{branch_id}/databases/{database_name}
         * @secure
         */
        _this.deleteProjectBranchDatabase = function (projectId, branchId, databaseName, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/databases/").concat(encodeURIComponent(databaseName)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves a list of Postgres roles from the specified branch. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. For related information, see [Manage roles](https://neon.tech/docs/manage/roles/).
         *
         * @tags Branch
         * @name ListProjectBranchRoles
         * @summary Get a list of roles
         * @request GET:/projects/{project_id}/branches/{branch_id}/roles
         * @secure
         */
        _this.listProjectBranchRoles = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/roles"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Creates a Postgres role in the specified branch. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. For related information, see [Manage roles](https://neon.tech/docs/manage/roles/). Connections established to the active compute endpoint will be dropped. If the compute endpoint is idle, the endpoint becomes active for a short period of time and is suspended afterward.
         *
         * @tags Branch
         * @name CreateProjectBranchRole
         * @summary Create a role
         * @request POST:/projects/{project_id}/branches/{branch_id}/roles
         * @secure
         */
        _this.createProjectBranchRole = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/roles"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Retrieves details about the specified role. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. You can obtain the `role_name` by listing the roles for a branch. In Neon, the terms "role" and "user" are synonymous. For related information, see [Manage roles](https://neon.tech/docs/manage/roles/).
         *
         * @tags Branch
         * @name GetProjectBranchRole
         * @summary Get role details
         * @request GET:/projects/{project_id}/branches/{branch_id}/roles/{role_name}
         * @secure
         */
        _this.getProjectBranchRole = function (projectId, branchId, roleName, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/roles/").concat(encodeURIComponent(roleName)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Deletes the specified Postgres role from the branch. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. You can obtain the `role_name` by listing the roles for a branch. For related information, see [Manage roles](https://neon.tech/docs/manage/roles/).
         *
         * @tags Branch
         * @name DeleteProjectBranchRole
         * @summary Delete a role
         * @request DELETE:/projects/{project_id}/branches/{branch_id}/roles/{role_name}
         * @secure
         */
        _this.deleteProjectBranchRole = function (projectId, branchId, roleName, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/roles/").concat(encodeURIComponent(roleName)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves the password for the specified Postgres role, if possible. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. You can obtain the `role_name` by listing the roles for a branch. For related information, see [Manage roles](https://neon.tech/docs/manage/roles/).
         *
         * @tags Branch
         * @name GetProjectBranchRolePassword
         * @summary Get role password
         * @request GET:/projects/{project_id}/branches/{branch_id}/roles/{role_name}/reveal_password
         * @secure
         */
        _this.getProjectBranchRolePassword = function (projectId, branchId, roleName, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/roles/").concat(encodeURIComponent(roleName), "/reveal_password"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Resets the password for the specified Postgres role. Returns a new password and operations. The new password is ready to use when the last operation finishes. The old password remains valid until last operation finishes. Connections to the compute endpoint are dropped. If idle, the compute endpoint becomes active for a short period of time. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. You can obtain the `role_name` by listing the roles for a branch. For related information, see [Manage roles](https://neon.tech/docs/manage/roles/).
         *
         * @tags Branch
         * @name ResetProjectBranchRolePassword
         * @summary Reset the role password
         * @request POST:/projects/{project_id}/branches/{branch_id}/roles/{role_name}/reset_password
         * @secure
         */
        _this.resetProjectBranchRolePassword = function (projectId, branchId, roleName, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/roles/").concat(encodeURIComponent(roleName), "/reset_password"), method: 'POST', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves the list of VPC endpoint restrictions for the specified project. This endpoint is under active development and its semantics may change in the future.
         *
         * @tags Project
         * @name ListProjectVpcEndpoints
         * @summary Get the list of VPC endpoint restrictions
         * @request GET:/projects/{project_id}/vpc-endpoints
         * @secure
         */
        _this.listProjectVpcEndpoints = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/vpc-endpoints"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Configures the specified VPC endpoint as restriction for the project, or updates the existing restriction. When a VPC endpoint is assigned as a restriction, only connections from this specific VPC are accepted. Note that a VPC endpoint can only used as a restriction on a project after it has been assigned to the parent organization. This endpoint is under active development and its semantics may change in the future.
         *
         * @tags Project
         * @name AssignProjectVpcEndpoint
         * @summary Assign or update a VPC endpoint restriction
         * @request POST:/projects/{project_id}/vpc-endpoints/{vpc_endpoint_id}
         * @secure
         */
        _this.assignProjectVpcEndpoint = function (projectId, vpcEndpointId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/vpc-endpoints/").concat(encodeURIComponent(vpcEndpointId)), method: 'POST', body: data, secure: true, type: ContentType.Json }, params));
        };
        /**
         * @description Deletes the specified VPC endpoint restriction from the specified project. This endpoint is under active development and its semantics may change in the future.
         *
         * @tags Project
         * @name DeleteProjectVpcEndpoint
         * @summary Delete a VPC endpoint
         * @request DELETE:/projects/{project_id}/vpc-endpoints/{vpc_endpoint_id}
         * @secure
         */
        _this.deleteProjectVpcEndpoint = function (projectId, vpcEndpointId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/vpc-endpoints/").concat(encodeURIComponent(vpcEndpointId)), method: 'DELETE', secure: true }, params));
        };
        /**
         * @description Creates a compute endpoint for the specified branch. An endpoint is a Neon compute instance. There is a maximum of one read-write compute endpoint per branch. If the specified branch already has a read-write compute endpoint, the operation fails. A branch can have multiple read-only compute endpoints. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain `branch_id` by listing the project's branches. A `branch_id` has a `br-` prefix. For supported regions and `region_id` values, see [Regions](https://neon.tech/docs/introduction/regions/). For more information about compute endpoints, see [Manage computes](https://neon.tech/docs/manage/endpoints/).
         *
         * @tags Endpoint
         * @name CreateProjectEndpoint
         * @summary Create a compute endpoint
         * @request POST:/projects/{project_id}/endpoints
         * @secure
         */
        _this.createProjectEndpoint = function (projectId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/endpoints"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Retrieves a list of compute endpoints for the specified project. A compute endpoint is a Neon compute instance. You can obtain a `project_id` by listing the projects for your Neon account. For information about compute endpoints, see [Manage computes](https://neon.tech/docs/manage/endpoints/).
         *
         * @tags Endpoint
         * @name ListProjectEndpoints
         * @summary Get a list of compute endpoints
         * @request GET:/projects/{project_id}/endpoints
         * @secure
         */
        _this.listProjectEndpoints = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/endpoints"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about the specified compute endpoint. A compute endpoint is a Neon compute instance. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain an `endpoint_id` by listing your project's compute endpoints. An `endpoint_id` has an `ep-` prefix. For information about compute endpoints, see [Manage computes](https://neon.tech/docs/manage/endpoints/).
         *
         * @tags Endpoint
         * @name GetProjectEndpoint
         * @summary Get a compute endpoint
         * @request GET:/projects/{project_id}/endpoints/{endpoint_id}
         * @secure
         */
        _this.getProjectEndpoint = function (projectId, endpointId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/endpoints/").concat(encodeURIComponent(endpointId)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Delete the specified compute endpoint. A compute endpoint is a Neon compute instance. Deleting a compute endpoint drops existing network connections to the compute endpoint. The deletion is completed when last operation in the chain finishes successfully. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain an `endpoint_id` by listing your project's compute endpoints. An `endpoint_id` has an `ep-` prefix. For information about compute endpoints, see [Manage computes](https://neon.tech/docs/manage/endpoints/).
         *
         * @tags Endpoint
         * @name DeleteProjectEndpoint
         * @summary Delete a compute endpoint
         * @request DELETE:/projects/{project_id}/endpoints/{endpoint_id}
         * @secure
         */
        _this.deleteProjectEndpoint = function (projectId, endpointId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/endpoints/").concat(encodeURIComponent(endpointId)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Updates the specified compute endpoint. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain an `endpoint_id` and `branch_id` by listing your project's compute endpoints. An `endpoint_id` has an `ep-` prefix. A `branch_id` has a `br-` prefix. For more information about compute endpoints, see [Manage computes](https://neon.tech/docs/manage/endpoints/). If the returned list of operations is not empty, the compute endpoint is not ready to use. The client must wait for the last operation to finish before using the compute endpoint. If the compute endpoint was idle before the update, it becomes active for a short period of time, and the control plane suspends it again after the update.
         *
         * @tags Endpoint
         * @name UpdateProjectEndpoint
         * @summary Update a compute endpoint
         * @request PATCH:/projects/{project_id}/endpoints/{endpoint_id}
         * @secure
         */
        _this.updateProjectEndpoint = function (projectId, endpointId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/endpoints/").concat(encodeURIComponent(endpointId)), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Starts a compute endpoint. The compute endpoint is ready to use after the last operation in chain finishes successfully. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain an `endpoint_id` by listing your project's compute endpoints. An `endpoint_id` has an `ep-` prefix. For information about compute endpoints, see [Manage computes](https://neon.tech/docs/manage/endpoints/).
         *
         * @tags Endpoint
         * @name StartProjectEndpoint
         * @summary Start a compute endpoint
         * @request POST:/projects/{project_id}/endpoints/{endpoint_id}/start
         * @secure
         */
        _this.startProjectEndpoint = function (projectId, endpointId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/endpoints/").concat(encodeURIComponent(endpointId), "/start"), method: 'POST', secure: true, format: 'json' }, params));
        };
        /**
         * @description Suspend the specified compute endpoint You can obtain a `project_id` by listing the projects for your Neon account. You can obtain an `endpoint_id` by listing your project's compute endpoints. An `endpoint_id` has an `ep-` prefix. For information about compute endpoints, see [Manage computes](https://neon.tech/docs/manage/endpoints/).
         *
         * @tags Endpoint
         * @name SuspendProjectEndpoint
         * @summary Suspend a compute endpoint
         * @request POST:/projects/{project_id}/endpoints/{endpoint_id}/suspend
         * @secure
         */
        _this.suspendProjectEndpoint = function (projectId, endpointId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/endpoints/").concat(encodeURIComponent(endpointId), "/suspend"), method: 'POST', secure: true, format: 'json' }, params));
        };
        /**
         * @description Restart the specified compute endpoint: suspend immediately followed by start operations. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain an `endpoint_id` by listing your project's compute endpoints. An `endpoint_id` has an `ep-` prefix. For information about compute endpoints, see [Manage computes](https://neon.tech/docs/manage/endpoints/).
         *
         * @tags Endpoint
         * @name RestartProjectEndpoint
         * @summary Restart a compute endpoint
         * @request POST:/projects/{project_id}/endpoints/{endpoint_id}/restart
         * @secure
         */
        _this.restartProjectEndpoint = function (projectId, endpointId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/endpoints/").concat(encodeURIComponent(endpointId), "/restart"), method: 'POST', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves consumption metrics for Scale and Business plan accounts. History begins at the time of upgrade. Available for Scale and Business plan users only.
         *
         * @tags Consumption
         * @name GetConsumptionHistoryPerAccount
         * @summary Get account consumption metrics
         * @request GET:/consumption_history/account
         * @secure
         */
        _this.getConsumptionHistoryPerAccount = function (query, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/consumption_history/account", method: 'GET', query: query, secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves consumption metrics for Scale and Business plan projects. History begins at the time of upgrade. Available for Scale and Business plan users only. Issuing a call to this API does not wake a project's compute endpoint.
         *
         * @tags Consumption
         * @name GetConsumptionHistoryPerProject
         * @summary Get consumption metrics for each project
         * @request GET:/consumption_history/projects
         * @secure
         */
        _this.getConsumptionHistoryPerProject = function (query, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/consumption_history/projects", method: 'GET', query: query, secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about the specified organization.
         *
         * @tags Organizations
         * @name GetOrganization
         * @summary Get organization details
         * @request GET:/organizations/{org_id}
         * @secure
         */
        _this.getOrganization = function (orgId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves the API keys for the specified organization. The response does not include API key tokens. A token is only provided when creating an API key. API keys can also be managed in the Neon Console. For more information, see [Manage API keys](https://neon.tech/docs/manage/api-keys/).
         *
         * @tags Organizations
         * @name ListOrgApiKeys
         * @summary Get a list of organization API keys
         * @request GET:/organizations/{org_id}/api_keys
         * @secure
         */
        _this.listOrgApiKeys = function (orgId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/api_keys"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Creates an API key for the specified organization. The `key_name` is a user-specified name for the key. This method returns an `id` and `key`. The `key` is a randomly generated, 64-bit token required to access the Neon API. API keys can also be managed in the Neon Console. See [Manage API keys](https://neon.tech/docs/manage/api-keys/).
         *
         * @tags Organizations
         * @name CreateOrgApiKey
         * @summary Create an organization API key
         * @request POST:/organizations/{org_id}/api_keys
         * @secure
         */
        _this.createOrgApiKey = function (orgId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/api_keys"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Revokes the specified organization API key. An API key that is no longer needed can be revoked. This action cannot be reversed. You can obtain `key_id` values by listing the API keys for an organization. API keys can also be managed in the Neon Console. See [Manage API keys](https://neon.tech/docs/manage/api-keys/).
         *
         * @tags Organizations
         * @name RevokeOrgApiKey
         * @summary Revoke an organization API key
         * @request DELETE:/organizations/{org_id}/api_keys/{key_id}
         * @secure
         */
        _this.revokeOrgApiKey = function (orgId, keyId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/api_keys/").concat(encodeURIComponent(keyId)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about the specified organization members.
         *
         * @tags Organizations
         * @name GetOrganizationMembers
         * @summary Get organization members details
         * @request GET:/organizations/{org_id}/members
         * @secure
         */
        _this.getOrganizationMembers = function (orgId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/members"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about the specified organization member.
         *
         * @tags Organizations
         * @name GetOrganizationMember
         * @summary Get organization member details
         * @request GET:/organizations/{org_id}/members/{member_id}
         * @secure
         */
        _this.getOrganizationMember = function (orgId, memberId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/members/").concat(encodeURIComponent(memberId)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Only an admin can perform this action.
         *
         * @tags Organizations
         * @name UpdateOrganizationMember
         * @summary Update the role for an organization member
         * @request PATCH:/organizations/{org_id}/members/{member_id}
         * @secure
         */
        _this.updateOrganizationMember = function (orgId, memberId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/members/").concat(encodeURIComponent(memberId)), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Remove member from the organization. Only an admin of the organization can perform this action. If another admin is being removed, it will not be allows in case it is the only admin left in the organization.
         *
         * @tags Organizations
         * @name RemoveOrganizationMember
         * @summary Remove member from the organization
         * @request DELETE:/organizations/{org_id}/members/{member_id}
         * @secure
         */
        _this.removeOrganizationMember = function (orgId, memberId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/members/").concat(encodeURIComponent(memberId)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about extended invitations for the specified organization
         *
         * @tags Organizations
         * @name GetOrganizationInvitations
         * @summary Get organization invitation details
         * @request GET:/organizations/{org_id}/invitations
         * @secure
         */
        _this.getOrganizationInvitations = function (orgId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/invitations"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Creates invitations for a specific organization. If the invited user has an existing account, they automatically join as a member. If they don't yet have an account, they are invited to create one, after which they become a member. Each invited user receives an email notification.
         *
         * @tags Organizations
         * @name CreateOrganizationInvitations
         * @summary Create organization invitations
         * @request POST:/organizations/{org_id}/invitations
         * @secure
         */
        _this.createOrganizationInvitations = function (orgId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/invitations"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Retrieves the list of VPC endpoints for the specified organization. This endpoint is under active development and its semantics may change in the future.
         *
         * @tags Organizations
         * @name ListOrganizationVpcEndpoints
         * @summary Get the list of VPC endpoints
         * @request GET:/organizations/{org_id}/vpc/region/{region_id}/vpc-endpoints
         * @secure
         */
        _this.listOrganizationVpcEndpoints = function (orgId, regionId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/vpc/region/").concat(encodeURIComponent(regionId), "/vpc-endpoints"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves detailed information about the VPC endpoint. This endpoint is under active development and its semantics may change in the future.
         *
         * @tags Organizations
         * @name GetOrganizationVpcEndpointDetails
         * @summary Retrieve the state of a VPC endpoint configuration
         * @request GET:/organizations/{org_id}/vpc/region/{region_id}/vpc-endpoints/{vpc_endpoint_id}
         * @secure
         */
        _this.getOrganizationVpcEndpointDetails = function (orgId, regionId, vpcEndpointId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/vpc/region/").concat(encodeURIComponent(regionId), "/vpc-endpoints/").concat(encodeURIComponent(vpcEndpointId)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Assigns the specified VPC endpoint to the specified organization or updates the existing assignment. This endpoint is under active development and its semantics may change in the future.
         *
         * @tags Organizations
         * @name AssignOrganizationVpcEndpoint
         * @summary Assign or update a VPC endpoint
         * @request POST:/organizations/{org_id}/vpc/region/{region_id}/vpc-endpoints/{vpc_endpoint_id}
         * @secure
         */
        _this.assignOrganizationVpcEndpoint = function (orgId, regionId, vpcEndpointId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/vpc/region/").concat(encodeURIComponent(regionId), "/vpc-endpoints/").concat(encodeURIComponent(vpcEndpointId)), method: 'POST', body: data, secure: true, type: ContentType.Json }, params));
        };
        /**
         * @description Deletes the specified VPC endpoint from the specified organization. This endpoint is under active development and its semantics may change in the future.
         *
         * @tags Organizations
         * @name DeleteOrganizationVpcEndpoint
         * @summary Delete a VPC endpoint
         * @request DELETE:/organizations/{org_id}/vpc/region/{region_id}/vpc-endpoints/{vpc_endpoint_id}
         * @secure
         */
        _this.deleteOrganizationVpcEndpoint = function (orgId, regionId, vpcEndpointId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/vpc/region/").concat(encodeURIComponent(regionId), "/vpc-endpoints/").concat(encodeURIComponent(vpcEndpointId)), method: 'DELETE', secure: true }, params));
        };
        /**
         * @description Retrieves the list of supported Neon regions
         *
         * @tags Region
         * @name GetActiveRegions
         * @summary Get current active regions
         * @request GET:/regions
         * @secure
         */
        _this.getActiveRegions = function (params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/regions", method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about the current Neon user account.
         *
         * @tags Users
         * @name GetCurrentUserInfo
         * @summary Get current user details
         * @request GET:/users/me
         * @secure
         */
        _this.getCurrentUserInfo = function (params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/users/me", method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about the current Neon user's organizations
         *
         * @tags Users, Organizations
         * @name GetCurrentUserOrganizations
         * @summary Get current user organizations list
         * @request GET:/users/me/organizations
         * @secure
         */
        _this.getCurrentUserOrganizations = function (params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/users/me/organizations", method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Transfers selected projects, identified by their IDs, from your personal account to a specified organization.
         *
         * @tags Users
         * @name TransferProjectsFromUserToOrg
         * @summary Transfer projects from your personal account to a specified destination account
         * @request POST:/users/me/projects/transfer
         * @secure
         */
        _this.transferProjectsFromUserToOrg = function (data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/users/me/projects/transfer", method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        return _this;
    }
    return Api;
}(HttpClient));
exports.Api = Api;
